<h1>Docker</h1><h3>一、初识 Docker</h3><p>在写代码时，常常会接触到好几个环境：开发环境、测试环境以及生产环境</p><p>在不同的环境上运行代码时，因为环境不同可能会导致代码运行错误，因此我们常常把代码和环境打包起来一起移送，这个打包起来的东西，我们就叫做 <strong>容器</strong>。</p><p>Docker 是一种<strong>容器技术</strong>，解决<strong>软件跨环境迁移</strong>的问题。</p><h4>1.1 Docker 的概念</h4><ul><li>Docker 是一个开源的应用容器引擎</li><li>诞生于 2013 年初，基于 Go 语言实现，dotCloud 公司出品（后改名为 Docker Inc）</li><li>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上</li><li>容器是完全使用沙箱机制，相互隔离</li><li>容器性能开销极低</li><li>Docker 从 17.03 版本之后分为 CE（Community Edition：社区版）和 EE（Enterprise Edition：企业版）</li></ul><h4>1.2 安装 Docker</h4><p>Docker 可以运行在 MAC、Windows、CentOS、Unbuntu等操作系统上，本文基于 CentOS 7 安装 Docker。</p><p>安装网址：https://www.docker.com</p><pre class="language-shell"><code class="language-shell"><span class="token comment"># 1. yum 包更新到最新</span><br>yum update<br><span class="token comment"># 2. 安装需要的软件包 yum-util 提供 yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br>yum <span class="token function">install</span> <span class="token parameter variable">-y</span> -yum-utils device-mapper-persistent-data lvm2<br><span class="token comment"># 3. 设置 yum 源</span><br>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br><span class="token comment"># 4. 安装docker,出现的输入界面都按y</span><br>yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce<br><span class="token comment"># 5. 查看docker版本，检验是否成功</span><br><span class="token function">docker</span> <span class="token parameter variable">-v</span></code></pre><h4>1.3 Docker 架构</h4><p><img src="Docker.assets/Snipaste_2024-03-11_14-54-02.png" alt="nipaste_2024-03-11_14-54-0"></p><p>上图中的 Clients 代表的是 客户端，我们后续的一些操作都是在客户端中进行的。</p><p>Host 是 docker 的核心，其中 local host 显然就代表着本机，而remote host 则代表远程机器。</p><p>在我们安装完 docker 后他会以 daemon（守护进程）的形式存在（后台运行的进程）。</p><p>在本机或者远程机器中，container 代表 容器，image 代表 镜像。其中 container 和 image 的定位有点类似与 类与对象，image 是根据 container 创建出的实例。</p><p>下面我们详细介绍一下 Image 与 Container：</p><ul><li><p><strong>Dokcer镜像（Image）</strong>，镜像是对静态的定义。它就相当于一个 root 文件系统，比如官方镜像 ubuntu:16.04 就包含了完整一套 Ubuntu16.04最小系统的root文件系统。</p></li><li><p><strong>Dokcer容器（Container）</strong>，容器是镜像运行时的实体，它可以被创建、启动、停止、删除、暂停等。</p></li></ul><p>而所谓<strong>仓库（Repository）</strong>，就是一个代码控制中心，用来保存镜像。</p><p>显然镜像源于 docker 提供的远程仓库，而这个远程仓库又分为 官方提供的 Docker hub 和 自己搭建的 private registry。</p><h4>1.4 配置 Docker 镜像加速器</h4><p>因为 docker 仓库位于国外，在不使用科学上网的手段，访问速度较慢，所以这里我们先配置镜像加速器。</p><p>而镜像加速器，比较常用的则就是以下几种，自己可以看着配置：</p><ul><li>USTC:中科大加速器（https://docker.mirrors.ustc.edu.cn）</li><li>阿里云</li><li>网易云</li><li>腾讯云</li></ul><p>这里我们使用 阿里云：</p><p>首先登录，随后搜索 容器镜像服务。</p><p><img src="Docker.assets/Snipaste_2024-03-25_20-52-01.png" alt="nipaste_2024-03-25_20-52-0"></p><p>随后打开 管理控制台，找到 镜像加速器 复制（每个人的地址都是特有，这里就不显示了）</p><p><img src="Docker.assets/Snipaste_2024-03-25_20-53-12.png" alt="nipaste_2024-03-25_20-53-1"></p><p>随后执行下面代码</p><pre class="language-shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker<br><span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'<br>{<br>  "registry-mirrors": ["你的镜像地址"]<br>}<br>EOF</span><br><span class="token function">sudo</span> systemctl daemon-reload<br><span class="token function">sudo</span> systemctl restart <span class="token function">docker</span></code></pre><p>如果失败，没关系，可以看这篇<a href="https://www.cnblogs.com/tianmingzh/articles/15861662.html">文章</a>，安装一下 <strong>docker desktop</strong>。之后我们也会详细介绍 docker desktop。</p><h3>二、Docker 命令</h3><p>由之前的架构图，显然，我们有以下几种命令：</p><ol><li>daemon 命令</li><li>container 命令</li><li>image 命令</li></ol><h4>2.1 daemon 命令</h4><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动docker</td></tr><tr><td>stystemctl status docker</td><td>查看docker状态</td></tr><tr><td>stystemctl stop docker</td><td>关闭docker</td></tr><tr><td>stystemctl restart docker</td><td>重启docker</td></tr><tr><td>stystemctl enable docker</td><td>自动启动docker</td></tr></tbody></table><p>ps.上述的stystemctl 属于系统命令，要根据自己使用的操作系统变化</p><h4>2.2 image 命令</h4><p>一般不确定是否有该版本的 镜像文件，可以上 docker hub 查找一下</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>docker images</td><td>查看镜像文件（软件和需要的运行环境）</td></tr><tr><td>docker search xxx</td><td>搜索xxx镜像文件</td></tr><tr><td>docker pull xxx[:版本号]</td><td>拉取对应版本的镜像文件，不写版本号默认最新</td></tr><tr><td>docker rmi 镜像ID/仓库名</td><td>删除镜像</td></tr><tr><td>docker rmi `docker images -q `</td><td>删除所有镜像</td></tr></tbody></table><h4>2.3 container 命令</h4><p>我们运行的 wsl 被叫做宿主机，而实际又会创建一个空间，即容器。</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>docker run -it --name=c1 centos:7 /bin/bash</td><td>创建容器（centos7、容器名为c1）</td></tr><tr><td>exit</td><td>退出容器</td></tr><tr><td>docker ps [-a // 加上查看所有容器]</td><td>查看容器</td></tr><tr><td>docker exec -it c2 /bin/bash</td><td>进入容器</td></tr><tr><td>docker stop 容器名/id</td><td>关闭容器</td></tr><tr><td>docker start 容器名/id</td><td>启动容器</td></tr><tr><td>docker rm 容器名/id</td><td>删除容器</td></tr><tr><td>docker inspect 容器名/id</td><td>查看容器信息</td></tr></tbody></table><p>参数说明：</p><ul><li>-i：保持容器运行。通常与 -t 同时使用。加入 it 这两个参数后，容器创建后会自动进入容器中，退出容器后，容器自动关闭</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>-d：以 daemon（守护后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭</li><li>-it 创建的容器一般被成为交互式容器，-id创建的容器一般被称为守护式容器</li><li>--name：为创建的容器命名</li></ul><h3>三、Docker 容器的数据卷</h3><h4>3.1 数据卷概念及作用</h4><p>在某些情况下我们迫不得已删除了容器，那么我们曾经存在于docker当中的一些数据怎么办呢？同时在使用docker时，我们能和外部机器交换文件吗？还有，在同一个宿主机中，可能存在多个容器，我们能让容器之间的数据产生交互吗？</p><p>以上问题，都可以被数据卷解决。</p><p>那么，什么是数据卷？</p><p><strong>数据卷</strong>，是<strong>宿主机中</strong>的一个目录或文件，当容器目录和数据卷目录绑定后，双方的修改立即会同步，同时一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷。</p><p>因此对于以上问题：</p><ol><li>即使删除docker，其数据卷仍然存在</li><li>可以通过数据卷与外部机器发生数据交换</li><li>通过多个容器绑定一个数据卷，从而进行交互</li></ol><p>总而言之，数据卷有以下作用：</p><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul><h4>3.2 配置数据卷</h4><p>创建启动容器时，使用 -v 参数 设置数据卷</p><pre class="language-shell"><code class="language-shell"><span class="token function">docker</span> run <span class="token punctuation">..</span>. <span class="token parameter variable">-v</span> 宿主机目录（文件）：容器内目录（文件）<span class="token punctuation">..</span>.</code></pre><p>注意事项：</p><ol><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ol><h4>3.3 配置数据卷容器</h4><p>多容器进行数据交互时，通过上述文本可知，可以采用多个容器挂载一个数据卷，但是多个容器难免会产生一些问题和混乱，因此我们还可以通过数据卷容器来实现。</p><p><img src="Docker.assets/Snipaste_2024-03-25_22-43-56.png" alt="nipaste_2024-03-25_22-43-5"></p><p>如上图所述，我们引入一个 Data Container 作为存储 Container1 和2的数据卷容器，即使c1或者c2出现了问题，我们还可以借助其他路径访问数据卷而不会对其余容器造成干扰。</p><p>以下是配置数据卷容器的步骤：</p><ol><li><p>创建启动c3数据卷容器，使用 -v 参数 设置数据卷</p><pre class="language-shell"><code class="language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c3 <span class="token parameter variable">-v</span> /volume centos:7 /bin/bash</code></pre></li><li><p>创建启动 c1 c2 容器，使用 --volumens-from 参数 设置数据卷</p><pre class="language-shell"><code class="language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c1 --volumes-from c3 centos:7 /bin/bash<br><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>c2 --volumes-form c3 centos:7 /bin/bash</code></pre></li></ol><h3>网络</h3><h4>11.1 docker</h4><p>初始化 docker 环境</p><pre class="language-shell"><code class="language-shell"><span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-aq</span><span class="token variable">)</span></span></code></pre><p>Linux 下获取 ip地址</p><pre class="language-shell"><code class="language-shell"><span class="token function">ip</span> addr</code></pre><pre class="language-shell"><code class="language-shell"><span class="token comment"># 随机启动一个</span><br><br><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-P</span> <span class="token parameter variable">--name</span> tomcat01<br><br>PS C:<span class="token punctuation">\</span>Users<span class="token punctuation">\</span>user<span class="token operator">></span> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat01 <span class="token function">ip</span> addr<br><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span><br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo<br>       valid_lft forever preferred_lft forever<br><span class="token number">2</span>: tunl0@NONE: <span class="token operator">&lt;</span>NOARP<span class="token operator">></span> mtu <span class="token number">1480</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span><br>    link/ipip <span class="token number">0.0</span>.0.0 brd <span class="token number">0.0</span>.0.0<br><span class="token number">3</span>: ip6tnl0@NONE: <span class="token operator">&lt;</span>NOARP<span class="token operator">></span> mtu <span class="token number">1452</span> qdisc noop state DOWN group default qlen <span class="token number">1000</span><br>    link/tunnel6 :: brd ::<br><span class="token number">12</span>: eth0@if13: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default<br>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span><br>    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br><br><span class="token comment"># 思考 ，linux 能不能 ping 通容器内部</span><br><span class="token comment">#可以#</span><br><br><span class="token comment"># linx 可以 ping 通 docker 容器内部</span></code></pre><blockquote><p>原理</p></blockquote><ol><li>我们每启动一个 docker 容器，docker 就会给 docker 容器分配个 ip，我们安装了docker，就会有个网卡 docker0，桥接模式，使用的技术是 evth-path技术！</li><li>在启动一个容器测试的时候，发现又多了一个网卡</li></ol><pre><code># 我们发现这个容器带来的网卡，都是一对对的
# evth-path 就是一堆虚拟的设备接口，他们都是成对的出现，一段连着协议，一段彼此相连
# 正因为有这个特性，evth-path 充当一个桥梁，链接各种虚拟网络设备
# OpenStac，Docker 容器之间的连接，OVS 连接，都是使用 evth-pair 技术
</code></pre><ol><li>测试 tomcat01 和 tomcat02 是否可以ping 通<ol><li>容器和容器之间是可以互相 ping 通的</li></ol></li></ol><p>结论：</p><p>tomcat01 和 tomcat02 是公用个路由器：docker0，所有的容器不指定网络的情况，都是 docker 容器会给我们分配一个默认可用的 ip</p><blockquote><p>小结</p></blockquote><p>Docker 中的所有的网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件！）</p><p>只要容器删除，对应网桥一对就没了！</p><h4>11.2 – link</h4><p>解决两个独立的 docker 项目不能互相 ping 的问题</p><pre><code>docker run -d -P --name tomcat03 --link tomcat02 tomcat
docker exec -it tomcat03 ping tomcat02

# 反向可以 ping 通吗？  不可以，需要配置
</code></pre><p>可以通过 insepect 可以看到很多东西</p><h4>11.3 自定义网络</h4><blockquote><p>查看所有 docker 网络</p></blockquote><pre><code>PS C:\Users\Anshu Chen&gt; docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
de74c8203497        bridge              bridge              local
550920e46e30        host                host                local
105ce7ef023f        none                null                local
</code></pre><p>网络模式：桥接 docker （默认）</p><p>none：不配置网络</p><p>host：和宿主机共享网络</p><p>container：容器网络连通（用的少！局限很大）</p><p>测试</p><pre><code># 我们直接启动的命令 --net bridge，而这个就是我们的 docker0
docker run -d -P --name tomcat01 tomcat
docker -d -P --name tomcat01 --net bridge tomcat

# docker0 特点：默认域名不能访问， --link 可以打通连接

# --driver bridge 桥接
# --subnet 192.168.0.0/16
# --gateway 
PS C:\Users\Anshu Chen&gt; docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
# 我们的网络就创建好了
c81d519694cb79a3b84dda1e20b0ce76521fcd7dbd9f25ff9db38c4717dc4ec1
PS C:\Users\Anshu Chen&gt; docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
de74c8203497        bridge              bridge              local
550920e46e30        host                host                local
c81d519694cb        mynet               bridge              local
105ce7ef023f        none                null                local

# 启动
docker run -d -P --name tomcat-net-01 --net mynet tomcat

PS C:\Users\Anshu Chen&gt; docker run -d -P --name tomcat-net-01 --net mynet tomcat
29efa1bcdb47c157b3737caa313aba619ef7c521f75babe6fff606443d7b0af5
PS C:\Users\Anshu Chen&gt; docker run -d -P --name tomcat-net-02 --net mynet tomcat
29c71809d2ba670ea7ccc9d64e64a784b813458273187584aca030d6cc7af0cc
PS C:\Users\Anshu Chen&gt; docker exec -it tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.108 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.067 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.088 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.077 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=6 ttl=64 time=0.046 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=7 ttl=64 time=0.052 ms
</code></pre><p>我们自定义的网络 docker都已经帮我们维护了对应的关系，推荐我们平时这样使用网络</p><p>好处：</p><p>redis - 不同的集群使用不同的网络，保证集群是安全和健康的</p><p>mysql - 不同的集群使用不同的网络，保证集群是安全和健康的</p><p>网络连通</p><pre><code># 测试连通
docker netword connect mynet tomcat01

# 连通之后，就是将 tomcat01 放了 mynet 网络下

# 一个容器两个 ip 地址
# 云服务器：公网 ip  私有 ip

# 01 连通
docker exec -it tomcat01 ping tomcat-net-01

# 02 是依然打不通的
docker exec -it tomcat02 ping tomcat-net-01
</code></pre><p>结论：</p><ul><li>假设要跨操作别人，就需要使用 docker network connect 连通！</li></ul>